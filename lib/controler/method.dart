import 'dart:io';import 'dart:typed_data';import 'package:intl/intl.dart';import 'package:cloud_firestore/cloud_firestore.dart';import 'package:dio/dio.dart';//import 'package:file_picker/file_picker.dart';import 'package:firebase_auth/firebase_auth.dart';import 'package:firebase_messaging/firebase_messaging.dart';import 'package:firebase_storage/firebase_storage.dart';import 'package:flutter/cupertino.dart';import 'package:flutter/material.dart';import 'package:fluttertoast/fluttertoast.dart';import 'package:get/get.dart';import 'package:image_gallery_saver/image_gallery_saver.dart';import 'package:notificationsystem_mobile/View/Login_page/login_main_page.dart';import 'package:permission_handler/permission_handler.dart';//import 'package:mime_type/mime_type.dart';import '../View/home_page.dart';import '../help/Colors.dart';import 'Alerts.dart';import 'auth/Account.dart';import 'auth/auth.dart';class Methods { static Stream<QuerySnapshot> getNews2() {   print("111111111111111111111111getNews2");   final newDateTime = DateTime.now();   print("NEW1 : ${newDateTime}");    return FirebaseFirestore.instance.collection('News').where("Stages",arrayContains: "${Account.stage}").snapshots();  }  static Stream<QuerySnapshot> getSchedules2() {    print("111111111111111111111111getSchedules2");    // Replace `myCollection` with the name of your Firestore collection    return FirebaseFirestore.instance.collection('Schedules').where("Stages",isEqualTo: "${Account.stage}").snapshots();  } static String getRealTimeDifference({required String oldTime})  {   DateTime newDateTime1 = DateTime.now();   final oldDateTime = DateTime.parse(oldTime);   final difference = newDateTime1.difference(oldDateTime);   print("oldDateTime : ${oldDateTime}");   print("oldTime : ${oldTime}");   print("newDateTime : ${newDateTime1}");   print("difference : ${difference}");   if (difference.inSeconds < 0) {     return "0 ثانية ";   }   else if (difference.inSeconds < 60) {     return "${difference.inSeconds} ثانية ";   } else if (difference.inMinutes < 60) {     return "${difference.inMinutes} دقيقة ";   } else if (difference.inHours < 24) {     return "${difference.inHours} ساعة ";   } else {     return "${difference.inDays} يوم ";   } }  static GlobalKey<FormState> formKey = GlobalKey<FormState>();  static List stagesUplode = ["First", "Second", "Third", "Fourth"];  static List stages = ["الاولى", "الثانية", "الثالثة", "الرابعة"];  /////////////////////////////////////////mobile///////// static RxList newsList = [].obs;  static dynamic newsList1 = [];  static RxBool news_post =false.obs; static String Stagesfield=""; static String studentNmae="";  static String DocumentReference1="";  static String ImageURL="";  static String studentToken="";  static String Stagesfieldsave="";  static String Studentnamesave="";  static RxBool getlocaldata = false.obs;  static RxBool studendtext =false.obs;  //////////////// static RxList news_listfavoritesflag=[].obs; static RxList news_listlikesflag=[].obs; static RxList news_listdislikesflag=[].obs;  static RxBool isConnected1=true.obs; ///////////  static  Future<void> getNews1()  async {    print("(((((((((((((((((((((((((((((((((((((getNews1))))))))))))))))))))))))))))))))");    try {      ///////////////////////////////////////       FirebaseFirestore.instance.settings.persistenceEnabled;      ///////////////////////////////////////////      QuerySnapshot querySnapshot = await FirebaseFirestore.instance.collection('News').where("Stages",arrayContains: "${Account.stage}").get();      newsList = querySnapshot.docs.obs;      newsList.forEach((element) {        print("newsList!.length: ${newsList.length}");      });     // await UserPreferences.saveDocumentsToLocal(collectionPath: 'News');      Future.delayed(const Duration(seconds: 0), () async {        news_post.value=true;        news_listfavoritesflag = List.filled(newsList.length, false).obs;        news_listlikesflag = List.filled(newsList.length, false).obs;        news_listdislikesflag = List.filled(newsList.length, false).obs;        for (int i = 0; i < newsList.length; i++) {          int likes_index = newsList[i]["likes"].indexOf(Account.documentID);          int favorites_index = newsList[i]["favorites"].indexOf(Account.documentID);          int dislikes_index = newsList[i]["dislikes"].indexOf(Account.documentID);          if (likes_index != -1) {            news_listlikesflag[i] = true;          }          if (favorites_index != -1) {            news_listfavoritesflag[i] = true;          }          if (dislikes_index != -1) {            news_listdislikesflag[i] = true;          }        }        print("news_listlikesflag: $news_listlikesflag");        print("news_listfavoritesflag: $news_listfavoritesflag");        print("news_listdislikesflag: $news_listdislikesflag");      });    } catch (e) {      news_post.value=false;      print('Error retrieving data from Firestore: $e');    }  } static FirebaseFirestore Studentscontact = FirebaseFirestore.instance; static Future<void> Student_text({required String studentName,required String text,required String stage}) async {   print('+++++++++++++++++++++++++++++++++6666666666666666666666666666666666666666');   DateTime today = DateTime.now();   try {     await Studentscontact.collection('Studentscontact').add({       'student_name': studentName,       'text': text,       'stage': stage,       'time':"${today.year}-${today.month}-${today.day}  ${DateFormat.jms().format(DateTime.now())}"     }).whenComplete(() => {       studendtext.value=false     });     print('Document added successfully!');   } catch (e) {     print('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');     print('Error adding document: $e');     studendtext.value=true;   } } static Future GetImageUrlToDocument({required String documentId,}) async {    print("documentId : ${documentId}");    try {      DocumentReference docRef = FirebaseFirestore.instance.collection('Student').doc(documentId);      DocumentSnapshot docSnapshot = await docRef.get();      dynamic fieldValue = docSnapshot.get('imageUrl');      print("imageUrl collection $fieldValue");      Account.userImageUrl = fieldValue;      // Display a success message.      print('Download URL delete to document with ID: $documentId');    } catch (e) {      print(e.reactive);      Account.userImageUrl="";    }  } static RxList Schedules_List = [].obs; static RxBool Schedules_post =false.obs; //////////////// static RxList Schedules_listfavoritesflag=[].obs; static RxList Schedules_listlikesflag=[].obs; static RxList Schedules_listdislikesflag=[].obs; static Future<void> deleteImage(String imageUrl,String id) async {    FirebaseStorage storage = FirebaseStorage.instance;    try {      try {        // Create a reference to the document you want to update.        DocumentReference documentReference = FirebaseFirestore.instance.collection('Student').doc(id);        // Update the document with the download URL.        await documentReference.update({          'imageUrl': "",        });        // Display a success message.        print('Download Token added to document with ID: $id');      } catch (e) {        print('Error adding download URL to document: $e');      }      Reference ref = storage.refFromURL(imageUrl);      await ref.delete();      Account.userImageUrl="";      print('Image deleted successfully.');    } catch (e) {      print("========================================");      print('Failed to delete image: $e');      Account.userImageUrl="";    }  }  static Future<void> refreshData2() async {    print("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&refreshData&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");    try {      final result = await InternetAddress.lookup('example.com');      if (result.isNotEmpty && result[0].rawAddress.isNotEmpty) {        print("////////////////_refreshData/////////////////////");        Methods.news_post.value = false;        await Methods.getNews1();        Methods.Schedules_post.value = false;        await Methods.getSchedules();      }    } on SocketException catch (_) {      print("////////////////No refreshData/////////////////////");    }    // Implement your data refreshing logic here    // This method will be called when the user swipes down on the screen  }  static Future<void> refreshData() async {    print("&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&refreshData&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&");    try {      final result = await InternetAddress.lookup('example.com');      if (result.isNotEmpty && result[0].rawAddress.isNotEmpty) {        print("////////////////_refreshData/////////////////////");        Methods.news_post.value = false;        await Methods.getNews1();        Methods.Schedules_post.value = false;        await Methods.getSchedules();      }    } on SocketException catch (_) {      print("////////////////No refreshData/////////////////////");      Methods.news_post.value = false;      await Methods.getNews1();      Methods.Schedules_post.value = false;      await Methods.getSchedules();    }    // Implement your data refreshing logic here    // This method will be called when the user swipes down on the screen  } ///////////// static Future<void> getSchedules() async {   print("(((((((((((((((((((((((((((((((((((((getSchedules))))))))))))))))))))))))))))))))");   try {     FirebaseFirestore.instance.settings.persistenceEnabled;     QuerySnapshot querySnapshot = await FirebaseFirestore.instance.collection('Schedules').where("Stages",isEqualTo: "${Account.stage}").get();     Schedules_List = querySnapshot.docs.obs;     Schedules_List.forEach((element) {       print("****************");     });     Future.delayed(const Duration(seconds: 0), () async {       Schedules_post.value=true;       Schedules_listfavoritesflag = List.filled(Schedules_List.length, false).obs;       Schedules_listlikesflag = List.filled(Schedules_List.length, false).obs;       Schedules_listdislikesflag = List.filled(Schedules_List.length, false).obs;       for (int i = 0; i < Schedules_List.length; i++) {         int likes_index = Schedules_List[i]["likes"].indexOf(Account.documentID);         int favorites_index = Schedules_List[i]["favorites"].indexOf(Account.documentID);         int dislikes_index = Schedules_List[i]["dislikes"].indexOf(Account.documentID);         if (likes_index != -1) {           Schedules_listlikesflag[i] = true;         }         if (favorites_index != -1) {           Schedules_listfavoritesflag[i] = true;         }         if (dislikes_index != -1) {           Schedules_listdislikesflag[i] = true;         }       }       print("Schedules_listlikesflag: $Schedules_listlikesflag");       print("Schedules_listfavoritesflag: $Schedules_listfavoritesflag");       print("Schedules_listdislikesflag: $Schedules_listdislikesflag");     });   } catch (e) {     Schedules_post.value=false;     print('Error retrieving data from Firestore: $e');   } }  ////////////////////////////////////////////////// static getHttp({required String url}) async {   try {     var response = await Dio().get(         "$url",         options: Options(responseType: ResponseType.bytes));     final result = await ImageGallerySaver.saveImage(         Uint8List.fromList(response.data),         quality: 80,         name: "${DateTime.now().toString()}");     print(result["isSuccess"]);     if(result["isSuccess"]==true){       _toastInfo("تم الحفظ");     }else{       _toastInfo("حدث خطاً");     }   } on Exception catch (e) {     _toastInfo("لا يوجد انترنت");     // TODO   } } static _toastInfo(String info) {   Fluttertoast.showToast(msg: info, toastLength: Toast.LENGTH_SHORT,backgroundColor: Colorsapp.Container_post,textColor: Colorsapp.mainColor); } static requestPermission() async {   Map<Permission, PermissionStatus> statuses = await [     Permission.storage,   ].request();   final info = statuses[Permission.storage].toString();   print("///////////////////////////////");   print(info);   print("///////////////////////////////");    if(info == "PermissionStatus.granted"){      _toastInfo("تم الوصول الى الصور");    }else{      _toastInfo("حدث خطأ في الوصول");    } }  /////////////////////////////////////////mobile/////////  static bool passflgs = false;  static bool emailflgs = false;  static RxBool emailExists=false.obs;  //Methods.emailExists.value = await Methods.checkEmailExists(Stages.Email_signin.text);  static Future<bool> checkEmailExists(String email) async {    print("////////////////checkEmailExists/////////////////////////////");    final CollectionReference usersCollection = FirebaseFirestore.instance.collection('Student');    QuerySnapshot snapshot = await usersCollection.where('email', isEqualTo: email).get();    return snapshot.docs.isNotEmpty;  }  static RxBool LogInflag = false.obs;  static RxBool isLogIn = false.obs;  static String stage = "";  static Future<Account?> signInWithEmailPassword(BuildContext context, {required String email, required String password} ) async {    DocumentReference1="";    stage = "";    studentNmae="";    try {      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(          email: email,          password: password)          .then((value) => {      });      var i = 0;      final QuerySnapshot querySnapshot = await FirebaseFirestore.instance          .collection("Student")          .where('email', isEqualTo:email) // Replace 'field_name' with the name of your field, and 'search_value' with the value you want to search for          .get().whenComplete(() => {})          .catchError((error) {        print("Error111111111: $error");        Alerts.showAlerterror(            context, "اعد المحاولة");      });      querySnapshot.docs.forEach((doc) {        print("Uid   ${doc.id}");        print(" ${i}  ${doc["stage"]}");        print("DocumentReference: ${doc.id}");        Methods.stage = doc["stage"];        Methods.DocumentReference1=doc.id;        Methods.studentNmae = doc["name"];        //Methods.ImageURL=doc["imageUrl"];        // prints a map containing the fields of the document      });      print("//////////////////////${Methods.stage}");     // await FirebaseMessaging.instance.unsubscribeFromTopic(Methods.stage);      if (stage ==stagesUplode[0]) {        Methods.Stagesfield = stages[0];      }      if (stage == stagesUplode[1]) {        Methods.Stagesfield = stages[1];      }      if (stage == stagesUplode[2]) {        Methods.Stagesfield = stages[2];      }      if (stage ==          stagesUplode[3]) {        Methods.Stagesfield = stages[3];      }      UserPreferences.saveCredentials(          email: email,          password: password,          isLogIn1: true,          stage: Methods.Stagesfield,          name: studentNmae,          id: DocumentReference1);      print("_isLogInq11111q${UserPreferences.getstate()}");      Account.name= studentNmae;      Account.email=email;      Account.stage=Methods.Stagesfield;      //print("await getToken() : >>>${await getToken()}");/////////     Get.off(const HomePage(indexOF: 0,),transition: Transition.fadeIn);      await Methods.refreshData();      await Methods.requestPermission();     // getToken();      Methods.studentToken= (await FirebaseMessaging.instance.getToken())!;      print("Methods.studentToken : >>>${Methods.studentToken}");      await Methods.addToken(documentId: DocumentReference1, token: Methods.studentToken);//////////////////////////////////    } on FirebaseAuthException catch (e) {      if (e.code == 'user-not-found') {        UserCredential userCredential = await FirebaseAuth.instance.createUserWithEmailAndPassword(          email: email,          password: '12345678',        );        await signInWithEmailPassword(context,email: email, password: '12345678');      } else if (e.code == 'wrong-password') {        Alerts.showAlerterror(            context, "الباسورد خطأ");        print(            'Wrong password provided for that user.');      } else {        Alerts.showAlerterror(context, "اعد المحاولة");        print(e);      }    } catch (e) {      print(e);      Alerts.showAlerterror(          context, "اعد المحاولة");    }  }  static FirebaseFirestore reversedtime1 = FirebaseFirestore.instance;  static Future<void> reversedtime({required oldtime,required String studentName,required String stage,required String title}) async {    print('(((((((((((((((((((((((((((((((reversedtime)))))))))))))))))))))))))))))))))');    var reversedtimedate = "";    DateTime newDateTime1 = DateTime.now();    final oldDateTime = DateTime.parse(oldtime);    final difference = newDateTime1.difference(oldDateTime);    print("oldDateTime : ${oldDateTime}");    print("oldTime : ${oldtime}");    print("newDateTime : ${newDateTime1}");    print("difference : ${difference}");    if (difference.inSeconds < 0) {      print("inSeconds 0");      reversedtimedate = "0 Seconds";    }    else {      reversedtimedate = "${difference.toString()}";    }    print("reversedtimedate : $reversedtimedate");    try {      await reversedtime1.collection('DurationTime').add({        'student_name': studentName,        'title': title,        'stage': stage,        'timetoreversed':reversedtimedate      }).whenComplete(() => {      });      print('timetoreversed Document added successfully!');    } catch (e) {      print('++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++');      print('Error adding timetoreversed to : $e');    }  }  static Future<void> resetPassword(BuildContext context,String email) async {    try {      await FirebaseAuth.instance.sendPasswordResetEmail(email: email);      print('Password reset email sent to $email');      Alerts.showAlertDONE(context, "تم ارسال الى الايميل");    } on FirebaseAuthException catch (e) {      if (e.code == 'user-not-found') {        Alerts.showAlerterror(context, "لا يوجد ايميل");      } else {        print(e.message);        if(e.message=="Given String is empty or null"){          Alerts.showAlerterror(context, "لا يوجد ايميل");        }        else if(e.message=="A network error (such as timeout, interrupted connection or unreachable host) has occurred."){          Alerts.showAlerterror(context, "لا يوجد انترنت");        }        }    } catch (e) {      Alerts.showAlerterror(context, "هناك خطأ");      print(e);    }  }  static Future addToken({required String documentId, required String token}) async {    try {      // Create a reference to the document you want to update.      DocumentReference documentReference = FirebaseFirestore.instance.collection('Student').doc(documentId);      // Update the document with the download URL.      await documentReference.update({        'Token': token,      });      // Display a success message.      print('Download Token addToken to document with ID: $documentId');    } catch (e) {      print('Error adding addToken URL to document: $e');    }  }  static Future deleteToken({required String documentId,}) async {    try {      // Create a reference to the document you want to update.      DocumentReference documentReference = FirebaseFirestore.instance.collection('Student').doc(documentId);      // Update the document with the download URL.      await documentReference.update({        'Token': "",      });      // Display a success message.      print('deleteToken Token  to document with ID: $documentId');    } catch (e) {      print('Error adding download URL to document: $e');    }  }  static Future<void> autfdgdfosignInWithEmailPassword1(BuildContext context, {required String email, required String password} ) async {    DocumentReference1="";    stage = "";    studentNmae="";    try {      final credential = await FirebaseAuth.instance.signInWithEmailAndPassword(          email: email,          password: password)          .then((value) => {      });      var i = 0;      final QuerySnapshot querySnapshot = await FirebaseFirestore.instance          .collection("Student")          .where('email', isEqualTo:email) // Replace 'field_name' with the name of your field, and 'search_value' with the value you want to search for          .get().whenComplete(() => {})          .catchError((error) {        print("Error111111111: $error");      });      querySnapshot.docs.forEach((doc) {        print("Uid   ${doc.id}");        print(" ${i}  ${doc["stage"]}");        print("DocumentReference: ${doc.id}");        Methods.stage = doc["stage"];        Methods.DocumentReference1=doc.id;        Methods.studentNmae = doc["name"];        //Methods.ImageURL=doc["imageUrl"];        // prints a map containing the fields of the document      });      if (stage ==stagesUplode[0]) {        Methods.Stagesfield = stages[0];      }      if (stage == stagesUplode[1]) {        Methods.Stagesfield = stages[1];      }      if (stage == stagesUplode[2]) {        Methods.Stagesfield =        stages[2];      }      if (stage ==          stagesUplode[3]) {        Methods.Stagesfield = stages[3];      }      print(" after Methods.Stagesfield  ${Methods.Stagesfield}");      Get.off(HomePage(indexOF: 0,),transition: Transition.noTransition);//////////////////////////////////    } on FirebaseAuthException catch (e) {      if (e.code == 'user-not-found') {        UserCredential userCredential = await FirebaseAuth.instance.createUserWithEmailAndPassword(          email: email,          password: '12345678',        );        Get.off(LogIn_Main_Page(),transition: Transition.noTransition);      } else if (e.code == 'wrong-password') {        print(            'Wrong password provided for that user.');        Get.off(LogIn_Main_Page(),transition: Transition.noTransition);      } else {        Get.off(LogIn_Main_Page(),transition: Transition.noTransition);      }    } catch (e) {      print("سششششششششششششششششش$e");    }  }}